#include <iostream>

// Проектирование классов в С++

// создание класса и реализация его свойств и действий
class ClassName {

private: // если не писать "private",
// то свойства класса будут доступны в других местах программы
  int first_feature;
  int second_feature;

public: // действий которыми можно пользоваться в других местах программы

  ClassName(int f, int s){ // специальная функция инициализации или конструктор
    this -> first_feature = f;
    this -> second_feature = s;
    // По сути конструктор представляет функцию, которая может принимать
    // параметры и которая должна называться по имени класса. В данном случае
    // конструктор принимает два параметра и передает их значения
    // полям first_feature и second_feature.
}

  ~ClassName(){ // выполение освобождения использованных объектом ресурсов
        std::cout << "Destructor called for ClassName " << std::endl;
        // По сути деструктор - это функция, которая называется по имени класса
        //(как и конструктор) и перед которой стоит тильда (~).
        //Деструктор не имеет возвращаемого значения и не принимает параметров.
        //Каждый класс может иметь только один деструктор.
    }


  void first_action() {
    std::cout << "ClassName make first_action()" << std::endl;
  }


  void second_action() {
    std::cout << "ClassName make second_action()" << std::endl;
  }
};

// Перезагрузка операторов

// Смотреть sems13-14 любой файл

/*
Ограничения на преименование операторов:

перегружать можно все имеющиеся операции, кроме

?: - тернарный оператор;
:: - доступ к вложенным именам;
. - доступ к полям;
.* - доступ к полям по указателю;
sizeof, typeid и операторы cast.

способы перегрузки унарных и бинарных операций отличаются

хотя бы один из аргументов перегружаемых оператором должен быть пользовательского типа

следующие операторы можно перегрузить только в качестве методов:

= - присваивание;
-> - доступ к полям по указателю;
() - вызов функции;
[] - доступ по индексу;
->* - доступ к указателю-на-поле по указателю;
операторы конверсии и управления памятью.

следующие операторы можно перегрузить только в виде внешних функций:

чтение из потока
запись в поток

*/




// Lvalue и Rvalue

/*
lvalue(locator value) - это объект, который занимает идентифицированное место
в памяти, можно получить его адрес

rvalue - это все то, что не lvalue или просто нельзя получить его адрес
(временные значения, литералы и тд)

 lvalue = rvalue;


 наличие идентичности (identity) – т. е. какого-то параметра,
 по которому можно понять, ссылаются ли два выражения на одну и ту же сущность
 или нет (например, адрес в памяти);

 возможность перемещения (can be moved from) – поддерживает семантику перемещения.
*/

int main(int argc, char const *argv[]) {
  /* code */
  return 0;
}
